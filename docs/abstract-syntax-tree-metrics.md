# Abstract Syntax Tree Metric Explanation

Imagine we're comparing two API calls for processing a customer order: processOrder(totalAmount=99.99, itemCount=3, isExpedited=true) with processOrder(totalAmount=49.99, itemCount=1, isExpedited=false). When we use an Abstract Syntax Tree (AST) to compare these function calls, it's like having a smart order processing system that understands the business logic behind each parameter. The AST breaks down the function calls into a structured tree where each parameter has different significance - changes in totalAmount might be more significant for business logic (affecting payment processing, fraud checks, and shipping insurance) than changes in isExpedited (which only affects shipping method). So when we calculate the similarity between these two orders, we're not just doing simple numerical comparisons. For instance, the difference between a $99.99 order and a $49.99 order might be weighted more heavily (0.4 of our similarity score) because it crosses important business thresholds, while the difference in expedition status might be weighted less (0.2 of our score) since it's a simpler boolean flag. This matches real-world scenarios where certain parameter differences have more far-reaching implications for how the function behaves - just like how in your Weaviate query comparison code, differences in core filters are weighted more heavily (0.25) than differences in grouping options (0.1).